###*
# @module server
###

###*
# ConnectionManager class
# @class ConnectionManager
# @module server
###
class ConnectionManager

  ###*
  # Initializes message counters
  # @class ConnectionManager
  # @constructor
  ###
  constructor: (@sockets) ->
    @lastServerMsgId = 0
    @lastClientMsgId = 0

  ###*
  # Creates new message object and initializes it's msgId
  # @method generateNewMessage
  # @return {Object} message stub with initialized msgId
  ###
  generateNewMessage: () =>
    message = {
      msgId: ++@lastServerMsgId,
      data: null
    }

  ###*
  # Sends message to given client to add provided task
  # @method sendNewTaskToPeer
  # @type {Object}
  # @param socket client connection handling socket 
  # @type Integer
  # @param taskId id of a new task
  # @type {String}
  # @param runFun code of the function to run
  # @return Integer msgId of sent message
  ###
  sendNewTaskToPeer: (socket, taskId, runFun) ->
    message = @generateNewMessage()
    message.data = {
      taskId: taskId,
      runFun: runFun
    }
    socket.emit 'addTask', message
    return message.msgId
  
  ###*
  # Sends message to given client to delete task
  # @method deleteTaskFromPeer
  # @type {Object}
  # @param socket client connection handling socket 
  # @type Integer
  # @param taskId id of a task
  # @return Integer msgId of sent message
  ###
  deleteTaskFromPeer: (socket, taskId) ->
    message = @generateNewMessage()
    message.data = {
      taskId: taskId
    }
    socket.emit 'deleteTask', message
    return message.msgId

  ###*
  # Sends message to given client to execute job
  # @method executeJobOnPeer
  # @type {Object}
  # @param socket client connection handling socket 
  # @type Integer
  # @param taskId id of a task
  # @type Integer
  # @param jobId id of a job
  # @type {Object}
  # @param jobArgs arguments for a job to execute
  # @return Integer msgId of sent message
  ###
  executeJobOnPeer: (socket, taskId, jobId, jobArgs) ->
    message = @generateNewMessage()
    message.data = {
      taskId: taskId,
      jobId: jobId,
      jobArgs: jobArgs
    }
    socket.emit 'executeJob', message
    return message.msgId

  ###*
  # Sends acknowledgment message to given client
  # @method sendAckToPeer
  # @type {Object}
  # @param socket client connection handling socket 
  # @type Integer
  # @param msgId id of a message to accept
  ###
  sendAckToPeer: (socket, msgId) ->
    message = {
      msgId: msgId
    }
    socket.emit 'ack', message

  onPeerConnected: (callback) =>
    @sockets.on 'connection', (socket) =>

      socket.on 'ack', (payload) =>
        console.log('Got message ' + payload.msgId + " acknowledgment")

      socket.on 'error', (payload) =>
        console.log('Message ' + payload.msgId + " generated error code " + payload.error)
        console.log('Details:')
        switch payload.error
          when 1
            console.log('No code for task ' + payload.details.taskId)
          when 2
            console.log('Job execution error for task: ' + payload.details.taskId + " job: " + payload.details.jobId)
            console.log('Reason: ' + payload.details.reason)
          when 3
            console.log('Job execution denied for task: ' + payload.details.taskId + " job: " + payload.details.jobId)
            console.log('Reason: ' + payload.details.reason)
          when 4
            console.log('Malformed operation, reason: ' + payload.details.reason)
          else
            console.log('Unknown error code')

      socket.on 'result', (payload) =>
        @lastClientMsgId = payload.msgId
        console.log('Received partial task result:')
        console.log('Message: ' + payload.msgId)  #Note that this message id is generated by client
        console.log('Task: ' + payload.data.taskId)
        console.log('Job: ' + payload.data.jobId)
        console.log('Result: ' + payload.data.jobResult)
        console.log('Sending acknowledgment to client')
        @sendAckToPeer(socket, payload.msgId)

      callback(socket)  

  onPeerDisconnected: (callback) ->
    @sockets.on 'disconnect', callback

  # TODO : document callback and test it somehow
  onCodeLoaded: (callback) ->
    @sockets.on 'code_loaded', callback

  onResultReady: (callback) ->
    @sockets.on 'result_ready', callback

  # TODO : wrap up clients in a class allowing for custom events
  getActiveConnections: ->
    @sockets.clients()

module.exports = ConnectionManager
